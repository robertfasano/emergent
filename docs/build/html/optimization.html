

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Optimization &mdash; EMERGENT 0.1alpha documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="EMERGENT 0.1alpha documentation" href="index.html"/>
        <link rel="next" title="Network flow" href="networkflow.html"/>
        <link rel="prev" title="Control" href="architecture/control.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> EMERGENT
          

          
          </a>

          
            
            
              <div class="version">
                0.1alpha
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">EMERGENT</a></li>
<li class="toctree-l1"><a class="reference internal" href="architecture.html">Architecture</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Optimization</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#steady-state-optimization">Steady-state optimization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#state-representation">State representation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1">Optimization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-fiber-alignment">Example: fiber alignment</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#time-dependent-optimization">Time-dependent optimization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sequence-representation">Sequence representation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-ramped-loading">Example: ramped loading</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#subspace-decoupling">Subspace decoupling</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="networkflow.html">Network flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="archetypes.html">Archetypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="devices.html">Devices</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">EMERGENT</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Optimization</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/optimization.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="optimization">
<h1>Optimization<a class="headerlink" href="#optimization" title="Permalink to this headline">¶</a></h1>
<p>What is an experiment? This question has many answers, but across many fields
an experiment can be described as:</p>
<ol class="arabic simple">
<li>Preparation of an initial sample</li>
<li>Performing a sequence of actions on the sample</li>
<li>Measuring the result</li>
</ol>
<p>In atomic physics, theorists love to track the state of an atomic system while
applying a series of unitaries; on the experimental side, it is useful instead
to track the state of the devices performing these actions. We suggest that any
experiment can be formally modeled through a functional</p>
<div class="math">
<p><img src="_images/math/65bdba47a29c61f04ffcccea9e632f1d717f733d.png" alt="\mathcal M(T) = \mathcal F[X(t&lt;T)]"/></p>
</div><p>In words: the measurement result at time <img class="math" src="_images/math/f2d283a2071f9d043c9e0b0f794a8880fa0d3ce9.png" alt="T"/> is a function of the state vector <img class="math" src="_images/math/7a7bb470119808e2db2879fc2b2526f467b7a40b.png" alt="X"/> at
all times leading up to the measurement. The state vector is a representation
of the individual states of all devices involved in the experiment. We are often
concerned with determining the state vector <img class="math" src="_images/math/57aa9e92b258f913c7bf39562ad555d3b3bd3d8b.png" alt="X(t)"/> which minimizes or maximizes
<img class="math" src="_images/math/c4cda3cad25d322644f7e600ee34dcb3488078b0.png" alt="\mathcal M(T)"/>.</p>
<div class="section" id="steady-state-optimization">
<h2>Steady-state optimization<a class="headerlink" href="#steady-state-optimization" title="Permalink to this headline">¶</a></h2>
<p>To make this formalism more intuitive, let's first study an experiment with a
memoryless cost functional <img class="math" src="_images/math/e603aea869366087b105593c483b7adbbe738133.png" alt="\mathcal F[X(T)]]`"/>, where the measurement depends on the input
state at time <img class="math" src="_images/math/f2d283a2071f9d043c9e0b0f794a8880fa0d3ce9.png" alt="T"/> but not the history. Let's see how EMERGENT describes this process.</p>
<div class="section" id="state-representation">
<h3>State representation<a class="headerlink" href="#state-representation" title="Permalink to this headline">¶</a></h3>
<p>Each physical degree of freedom is represented by an <a class="reference internal" href="architecture/input.html"><span class="doc">Input</span></a> node; in this case, there are two nodes labeled <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> which
represent the tip and tilt of the mirror. The <code class="docutils literal notranslate"><span class="pre">Input.state</span></code> attribute stores a
float representing the instantaneous state of the input.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Input.set(state)</span></code> method updates the state of the input to the
argument by requesting a new state from the parent <a class="reference internal" href="architecture/device.html"><span class="doc">Device</span></a> node. Device nodes
represent physical actuators such as the MEMS voltage control board; the Device
stores the state of its inputs in a dictionary with the example format
<code class="docutils literal notranslate"><span class="pre">Device.state</span> <span class="pre">=</span> <span class="pre">{'X':1,</span> <span class="pre">'Y':2}</span></code>.</p>
<p>When the Input node requests a new state, the <code class="docutils literal notranslate"><span class="pre">Device.actuate(state)</span></code> method
is called. This does two things: first, the <code class="docutils literal notranslate"><span class="pre">Device._actuate(state)</span></code> method
updates the physical state (the real tip/tilt), in this case via SPI commands
to a DAC on the MEMS driver board (note that the <code class="docutils literal notranslate"><span class="pre">Device.actuate()</span></code> method is
a property of the core Device class, while the private <code class="docutils literal notranslate"><span class="pre">Device._actuate()</span></code>
method must be implemented separately for each device). Next, the <code class="docutils literal notranslate"><span class="pre">Device.update(state)</span></code>
method is called. This keeps the virtual state synchronized with the physical
state by simultaneously updating the state variables of the Input, Device, and Control
nodes.</p>
<p>The <a class="reference internal" href="architecture/control.html"><span class="doc">Control</span></a> node oversees the entire experiment by issuing commands to the inputs
during optimization algorithms. It contains methods, tagged with the &#64;cost decorator,
which prepare and evaluate a target state. The state of the Control node is
represented similarly to the Device node, but the dictionary keys also include
the device names; for example, the Control node called <code class="docutils literal notranslate"><span class="pre">autoAlign</span></code> is connected
to a <code class="docutils literal notranslate"><span class="pre">MEMS</span></code> Device node which has two inputs <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code>, so the state is
<code class="docutils literal notranslate"><span class="pre">Control.state</span> <span class="pre">=</span> <span class="pre">{'MEMS.X':1,</span> <span class="pre">'MEMS.Y':2}</span></code>.</p>
</div>
<div class="section" id="id1">
<h3>Optimization<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>To make the connection clear between the code and the formalism, here is the
typical optimization sequence:</p>
<ol class="arabic">
<li><p class="first">The initial state <img class="math" src="_images/math/7a7bb470119808e2db2879fc2b2526f467b7a40b.png" alt="X"/> is represented through a dict <code class="docutils literal notranslate"><span class="pre">state</span></code>, and is passed into the <a class="reference internal" href="archetypes/optimizer.html"><span class="doc">Optimizer</span></a> module along with a cost function <code class="docutils literal notranslate"><span class="pre">cost</span></code>.</p>
</li>
<li><p class="first">The cost function <img class="math" src="_images/math/3c69b8a5662675d2c528a60615836e57f7a63876.png" alt="\mathcal F[X]"/> is evaluated by calling <code class="docutils literal notranslate"><span class="pre">cost(state)</span></code>.</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><code class="docutils literal notranslate"><span class="pre">Control.actuate(state)</span></code> calls the <code class="docutils literal notranslate"><span class="pre">Input.set(state)</span></code> method on every input in the state vector.</li>
<li>Each Input node requests a new state from the Device node.</li>
<li>The Device node runs <code class="docutils literal notranslate"><span class="pre">Device.actuate(state)</span></code> to update the physical state.</li>
<li>A physical measurement of <img class="math" src="_images/math/3c69b8a5662675d2c528a60615836e57f7a63876.png" alt="\mathcal F[X]"/> is made.</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">The learner updates its knowledge of the cost landscape <img class="math" src="_images/math/3c69b8a5662675d2c528a60615836e57f7a63876.png" alt="\mathcal F[X]"/>, suggests a new state <img class="math" src="_images/math/7a7bb470119808e2db2879fc2b2526f467b7a40b.png" alt="X"/>, and returns to step 2.</p>
</li>
</ol>
</div>
<div class="section" id="example-fiber-alignment">
<h3>Example: fiber alignment<a class="headerlink" href="#example-fiber-alignment" title="Permalink to this headline">¶</a></h3>
<p>An example which is ubiquitous in AMO
physics is the fiber coupling problem, in which we want to steer a laser beam
into an optical fiber to maximize the light transmitted on the other end. This
is typically done by controlling the tip and tilt of two mirrors, where the more
distant mirror is used to translate the beam relative to the fiber tip while the
closer is used to adjust the angle. If only one mirror is adjusted, the measurement
will look like the Gaussian overlap of the beam and the fiber mode, and simple
hill-climbing algorithms can be employed to find the tip/tilt pair <img class="math" src="_images/math/497184a5e83d0159a4bf15b0bb89dc5aa40cce7d.png" alt="(x,y)"/> which
maximizes the measurement <img class="math" src="_images/math/450a8e2c2320d77181e0d4fc68c947e9a5de8ecb.png" alt="M"/>. This is an example of a convex optimization problem,
where the local minimum is also the global minimum.</p>
<p>And the results: the graphs below show a real fiber alignment routine run by EMERGENT. The left
graph plots the simplex trajectory over the independently measured cost landscape,
while the right graph shows a time series of the optimization, demonstrating
convergence in several seconds.</p>
<a class="reference internal image-reference" href="_images/simplex_parametric.png"><img alt="_images/simplex_parametric.png" src="_images/simplex_parametric.png" style="width: 49%;" /></a>
<a class="reference internal image-reference" href="_images/simplex_time_series.png"><img alt="_images/simplex_time_series.png" src="_images/simplex_time_series.png" style="width: 49%;" /></a>
</div>
</div>
<div class="section" id="time-dependent-optimization">
<h2>Time-dependent optimization<a class="headerlink" href="#time-dependent-optimization" title="Permalink to this headline">¶</a></h2>
<p>Turning now to a more complicated time-dependent cost functional, we consider
the problem of magneto-optical trapping, in which atoms are trapped at the zero
of a quadrupole magnetic field in a red-detuned laser beam. The problem can be
formulated as a memoryless cost functional depending on parameters such as the
field strength and laser detuning, but the trapping can be improved by adding a
time-dependent ramp such that the Doppler and Zeeman shifts keep the beam resonant
while the atoms cool. In this case we are tasked with determining not the
steady-state parameter values but instead the ramp shape which maximizes the
number of trapped atoms. Algorithmic optimization of atom cooling has been
achieved through parameterized ramps, where each of the <img class="math" src="_images/math/b9d10b54744d07746b97f53c55eb98046fd76c8c.png" alt="d"/> inputs <img class="math" src="_images/math/7854a4b2875dd614f1735c2ad17262fb97d129b7.png" alt="x(t)"/> is stepped
discretely through <img class="math" src="_images/math/f4170ed8938b79490d8923857962695514a8e4cb.png" alt="N"/> steps <img class="math" src="_images/math/eace9a4b93943e036c20dda8884225f40eb678d2.png" alt="(t_1,...,t_N)"/>; the <img class="math" src="_images/math/f4170ed8938b79490d8923857962695514a8e4cb.png" alt="N"/> setpoints of each parameter are used
as inputs into a regressor which interpolates the <img class="math" src="_images/math/d2d1abf0516f12738084e775cdc7ef96ff030d0b.png" alt="Nd"/>-dimensional cost landscape
to search for a minimum. Unlike the simple fiber coupling example, these problems
possess very complex, high-dimensional cost landscapes which may have many local
minima as well as high shot-to-shot noise, so deterministic convex solvers such
as gradient descent algorithms are unlikely to find the global minimum. A solution
is to use stochastic optimization algorithms, such as differential evolution or
stochastic artificial neural networks. Here the objective is to model rather than
simply explore the cost landscape, and to use information gained in each cycle
to improve the determination of the global maximum.</p>
<div class="section" id="sequence-representation">
<h3>Sequence representation<a class="headerlink" href="#sequence-representation" title="Permalink to this headline">¶</a></h3>
<p>Let's look at how EMERGENT handles sequences. For example, let's
consider a Control node called <code class="docutils literal notranslate"><span class="pre">MOT</span></code> with a Device node <code class="docutils literal notranslate"><span class="pre">laser</span></code> and and
an Input node <code class="docutils literal notranslate"><span class="pre">frequency</span></code>. We define a sequence of an Input node as a list of
tuples, where each tuple represents a point in the sequence; its first element
is the time, while its second element is the state at that time. Let's define a
four-step ramp over a 1 second experimental cycle:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">MOT</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="s1">&#39;laser.frequency&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">42</span><span class="p">),(</span><span class="mf">0.25</span><span class="p">,</span><span class="o">-</span><span class="mi">35</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">28</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.75</span><span class="p">,</span> <span class="o">-</span><span class="mi">21</span><span class="p">)]</span>
</pre></div>
</div>
<p>Now let's add a new Device <code class="docutils literal notranslate"><span class="pre">coils</span></code> with an Input <code class="docutils literal notranslate"><span class="pre">gradient</span></code>, which will
be ramped in a two-step sequence:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">MOT</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="s1">&#39;coils.gradient&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">50</span><span class="p">),(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">25</span><span class="p">)]</span>
</pre></div>
</div>
<p>Sequencing is handled by the <a class="reference internal" href="archetypes/clock.html"><span class="doc">Clock</span></a> module. The <code class="docutils literal notranslate"><span class="pre">Clock.prepare_sequence()</span></code> method
inspects the sequences of the individual inputs, then prepares a master sequence
composed of the total experimental state at all timesteps:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">MOT</span><span class="o">.</span><span class="n">clock</span><span class="o">.</span><span class="n">prepare_sequence</span><span class="p">()</span>
<span class="n">MOT</span><span class="o">.</span><span class="n">sequence</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="mf">0.25</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;laser.frequency&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">42</span><span class="p">,</span> <span class="s1">&#39;coils.gradient&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">}),</span>
 <span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;laser.frequency&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">35</span><span class="p">,</span> <span class="s1">&#39;coils.gradient&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">}),</span>
 <span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;laser.frequency&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">28</span><span class="p">,</span> <span class="s1">&#39;coils.gradient&#39;</span><span class="p">:</span> <span class="mi">25</span><span class="p">}),</span>
 <span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;laser.frequency&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">21</span><span class="p">,</span> <span class="s1">&#39;coils.gradient&#39;</span><span class="p">:</span> <span class="mi">25</span><span class="p">})]</span>
</pre></div>
</div>
<p>The sequence can be run for a single shot with <code class="docutils literal notranslate"><span class="pre">Control.clock.run_once()</span></code> or
looped with <code class="docutils literal notranslate"><span class="pre">Control.clock.start()</span></code>. For each tuple in the sequence, the state
dict is passed into the <code class="docutils literal notranslate"><span class="pre">Control.actuate()</span></code> method; afterwards, there is a delay
given by the first element of each tuple before the next actuation.</p>
</div>
<div class="section" id="example-ramped-loading">
<h3>Example: ramped loading<a class="headerlink" href="#example-ramped-loading" title="Permalink to this headline">¶</a></h3>
<p>For an example of a time dependent optimization problem, consider the 1D functional</p>
<div class="math">
<p><img src="_images/math/d87ef32ea7841c44f9ba4a9f24ca0ea80028a6a2.png" alt="\mathcal M(T) = \int_0^T \frac{1}{1+(1-xt)^2}dt,"/></p>
</div><p>which qualitatively reproduces the required behavior to
optimize a MOT - the functional is maximized for the ramp <img class="math" src="_images/math/2d5911d6eb8b1d097921d1866e7f8cceac14571d.png" alt="x=1/t"/>. If we were naive
to the form of the cost function, we could algorithmically maximize the function.
We discretize the inputs as <img class="math" src="_images/math/7b15fb2e290941368e8e71ddb269a44f3f53022b.png" alt="x_i=x(t_i)"/> and compute the cost function as</p>
<div class="math">
<p><img src="_images/math/116f18d48f7e20c52f6b312ff27535af686dce9b.png" alt="\mathcal M(T) = \frac{T}{N}\sum_{i=1}^N \frac{1}{1+(1-x_it_i)^2},"/></p>
</div><p>where <img class="math" src="_images/math/814c57411127a26298914d750d0b71a67fb273fc.png" alt="T=1"/>. This function is implemented in the <code class="docutils literal notranslate"><span class="pre">emergent/examples/basic</span></code>
network as <code class="docutils literal notranslate"><span class="pre">control.cost_ramp</span></code>, which takes a sequence as an argument. This
example can be run with the <code class="docutils literal notranslate"><span class="pre">TestControl.optimize_sequence()</span></code> function.</p>
<p>We'll initialize the state with a guess <img class="math" src="_images/math/932953aa7d3d30ec66b925d5ea84ee2e3e72ac89.png" alt="x_i=1"/> for all <img class="math" src="_images/math/df0deb143e5ac127f00bd248ee8001ecae572adc.png" alt="i"/> and run a
simplex algorithm to optimize the inputs. Note that EMERGENT's algorithms can
handle states or sequences interchangeably - if you pass in a state like
<code class="docutils literal notranslate"><span class="pre">state={'X':1,</span> <span class="pre">'Y':2}</span></code>, it decomposes it to array form <code class="docutils literal notranslate"><span class="pre">[1,2]</span></code> before
optimization, whereas a sequence like <code class="docutils literal notranslate"><span class="pre">{'X':[(0,0),(0.5,1)],</span> <span class="pre">'Y':[(0,2),</span> <span class="pre">(0.5,3)]}</span></code>
is represented in array form as <code class="docutils literal notranslate"><span class="pre">[0,1,2,3]</span></code>. After this, the algorithm doesn't
care if it's working with a state or sequence - it simply passes this array into
a cost function which actuates a state or runs a sequence and returns a result.</p>
</div>
</div>
<div class="section" id="subspace-decoupling">
<h2>Subspace decoupling<a class="headerlink" href="#subspace-decoupling" title="Permalink to this headline">¶</a></h2>
<p>The sophisticated algorithms contained in the EMERGENT library can optimize cost
functions of many degrees of freedom, but most powerful of all is the ability to
avoid this through subspace identification and dimensional reduction. By using
principal component analysis, EMERGENT will be able to project the cost landscape
onto a set of orthogonal virtual inputs, hence decomposing a high-dimensional
coupled optimization problem into many lower-dimensional problems. To see the
power of this, consider a grid search algorithm which searches for an optimum
point with <img class="math" src="_images/math/f4170ed8938b79490d8923857962695514a8e4cb.png" alt="N"/> uniformly sampled points for each of <img class="math" src="_images/math/b9d10b54744d07746b97f53c55eb98046fd76c8c.png" alt="d"/> devices. The
number of iterations required, <img class="math" src="_images/math/a2b16d132a79449cbbf75dc204c51dc2ed24568d.png" alt="N^d"/>, is entirely infeasible for even modest
numbers of devices - for example, just a coarse 10-step sampling with 10 connected
inputs would take 317 years with an experimental cycle of 1 Hz! However, by
diagonalizing the covariance matrix, the problem can be reduced into 10 1D
optimizations which can be performed independently, requiring only <img class="math" src="_images/math/d2d1abf0516f12738084e775cdc7ef96ff030d0b.png" alt="Nd"/> steps!
In doing so, we replace the physical inputs with virtual inputs, which are linear
combinations of the original ones.</p>
<p>For example, consider a cost landscape consisting of a stretched two-variable
Gaussian which is rotated by 30 degrees about the <img class="math" src="_images/math/683f2dd9129a91d21aaf1c04afa6f78b39d4cb0a.png" alt="z"/> axis. The effects of
the coupling are evident: performing a line search in <img class="math" src="_images/math/a59f68a4202623bb859a7093f0316bf466e6f75d.png" alt="x"/> or <img class="math" src="_images/math/276f7e256cbddeb81eee42e1efc348f3cb4ab5f8.png" alt="y"/>
alone will not in general find the maximum, since by changing one variable we
change the optimal position of the other. However, we can efficiently solve the
problem by rotating our inputs into a frame where they are decoupled. Then, we
can solve two separate 1D optimization problems in terms of the rotated inputs.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="networkflow.html" class="btn btn-neutral float-right" title="Network flow" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="architecture/control.html" class="btn btn-neutral" title="Control" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Robert Fasano.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1alpha',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="python" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="python" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Examples &mdash; EMERGENT 0.1alpha documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> EMERGENT
          

          
          </a>

          
            
            
              <div class="version">
                0.1alpha
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">EMERGENT</a></li>
<li class="toctree-l1"><a class="reference internal" href="architecture.html">Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="archetypes.html">Archetypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="devices.html">Devices</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">EMERGENT</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Examples</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/examples_old.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="examples">
<h1>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h1>
<div class="section" id="simple-network">
<h2>Simple network<a class="headerlink" href="#simple-network" title="Permalink to this headline">¶</a></h2>
<p>A full example for a simple network can be found in emergent/examples/basic.py.
In this example, a single Control node oversees two Device nodes, one with inputs
'X' and 'Y' and another with input 'Z'. Take a moment to look through the code
required to initialize the network: in <code class="docutils literal"><span class="pre">network.py</span></code>, we have simply imported
and instantiated the objects defined in the <code class="docutils literal"><span class="pre">devices</span></code> and <code class="docutils literal"><span class="pre">controls</span></code> folder.
EMERGENT hooks up the network under the hood - all you have to do is define the
node parent/child relationships.</p>
<p>EMERGENT uses a single script, <code class="docutils literal"><span class="pre">main.py</span></code>, to launch any connected network, which
is defined through its <code class="docutils literal"><span class="pre">network.py</span></code> file which is here in the <code class="docutils literal"><span class="pre">basic</span></code> folder.
You can start EMERGENT with this network from the root directory (<code class="docutils literal"><span class="pre">emergent</span></code>)
by running</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">ipython</span>
<span class="o">%</span><span class="n">run</span> <span class="n">main</span> <span class="n">basic</span>
</pre></div>
</div>
<p>Once EMERGENT launches, a GUI will open. The left pane displays the network tree;
Inputs can be changed by double-clicking on their values, entering a new value,
and pressing the Enter key.</p>
<p>The right pane allows optimization of selected inputs. With one or more inputs
selected in the left pane, you can choose an algorithm from the drop-down menu,
edit the parameters passed into the algorithm, and choose a cost function to
optimize.</p>
<p>Let's try tuning the <code class="docutils literal"><span class="pre">deviceA</span></code> inputs to optimize the <code class="docutils literal"><span class="pre">cost_coupled</span></code> function
using the <code class="docutils literal"><span class="pre">grid_search</span></code> algorithm and 30 steps per axis. Make sure to set
<code class="docutils literal"><span class="pre">plot:1</span></code> to display the output.</p>
<img alt="_images/examples_grid_search.png" src="_images/examples_grid_search.png" />
<p>When you click the Go! button, the parameter space will be sampled uniformly and
the inputs will be set to the best discovered point:</p>
<img alt="_images/examples_grid_search_result.png" src="_images/examples_grid_search_result.png" />
<p>In the following examples, we'll go beyond the GUI and get a feel for EMERGENT
from the command line.</p>
<div class="section" id="state-access-and-actuation">
<h3>State access and actuation<a class="headerlink" href="#state-access-and-actuation" title="Permalink to this headline">¶</a></h3>
<p>In this example, we will assume that the inputs are initialized to 0.
There are three ways that the state of one or more inputs can be changed.
First, we could act directly on the Input node:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">deviceA</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">deviceA</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">control</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
<span class="p">{</span><span class="s1">&#39;deviceA.X&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;deviceA.Y&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;deviceB.X&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;deviceB.Y&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
</pre></div>
</div>
<p>We can act on one or more inputs of a single device by passing in a target state to the <code class="docutils literal"><span class="pre">Device.actuate()</span></code> method:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">deviceA</span><span class="o">.</span><span class="n">actuate</span><span class="p">({</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">})</span>
<span class="k">print</span><span class="p">(</span><span class="n">deviceA</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">control</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
<span class="p">{</span><span class="s1">&#39;deviceA.X&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;deviceA.Y&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;deviceB.X&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;deviceB.Y&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
</pre></div>
</div>
<p>We can also act on any number of inputs across any number of devices through the <code class="docutils literal"><span class="pre">Control.actuate()</span></code> method:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">control</span><span class="o">.</span><span class="n">actuate</span><span class="p">({</span><span class="s1">&#39;deviceA.X&#39;</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;deviceA.Y&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;deviceB.X&#39;</span><span class="p">:</span><span class="mi">13</span><span class="p">})</span>
<span class="k">print</span><span class="p">(</span><span class="n">deviceA</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">deviceB</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">control</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">}</span>
<span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="mi">13</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
<span class="p">{</span><span class="s1">&#39;deviceA.X&#39;</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;deviceA.Y&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;deviceB.X&#39;</span><span class="p">:</span><span class="mi">13</span><span class="p">,</span> <span class="s1">&#39;deviceB.Y&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
</pre></div>
</div>
<p>No matter which method we use, the result is the same: the value of each targeted
Input node is changed, and both <code class="docutils literal"><span class="pre">device.state</span></code> and <code class="docutils literal"><span class="pre">control.state</span></code> are updated.</p>
</div>
<div class="section" id="state-recall">
<h3>State recall<a class="headerlink" href="#state-recall" title="Permalink to this headline">¶</a></h3>
<p>The current state of our Control node can be saved by running <code class="docutils literal"><span class="pre">control.save()</span></code>.
This stores the state dict in <code class="docutils literal"><span class="pre">basic/settings/control.txt</span></code>. The state can be
recovered at a later time by running <code class="docutils literal"><span class="pre">control.load()</span></code>, which will read the state
dict into memory and update included Input nodes to the loaded state.</p>
</div>
</div>
<div class="section" id="fiber-coupling">
<h2>Fiber coupling<a class="headerlink" href="#fiber-coupling" title="Permalink to this headline">¶</a></h2>
<p>As a simple yet highly useful application of EMERGENT, we present here a complete
walkthrough for setting up a new EMERGENT project implementing automated beam
alignment into an optical fiber.</p>
<div class="section" id="first-steps">
<h3>First steps<a class="headerlink" href="#first-steps" title="Permalink to this headline">¶</a></h3>
<p>Before writing any code, you'll need to prepare a project directory for your application in the same directory that houses your EMERGENT package. The emergent/template directory contains a blueprint project that you can copy and rename. Let's name it &quot;autoAlign&quot;.</p>
<p>You'll see several files and folders in the newly-created project directory:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">main.py</span></code>: the script which runs your project. In here, we'll import any modules we want to use, then define our experiment.</li>
<li><code class="docutils literal"><span class="pre">nodes</span></code>: an empty folder which will contain any project-specific classes inheriting from Node</li>
<li><code class="docutils literal"><span class="pre">settings</span></code>: an empty folder which will contain settings files for the experiment</li>
</ul>
<p>If you run into trouble at any point in this tutorial, you can check your code against the emergent/examples/autoAlign directory.</p>
</div>
<div class="section" id="building-the-experiment">
<h3>Building the experiment<a class="headerlink" href="#building-the-experiment" title="Permalink to this headline">¶</a></h3>
<p>Roughly five degrees of freedom are needed to optimize beam alignment into an optical fiber: tip/tilt controls for a pair of mirrors and z-translation of a lens to allow matching of the optical mode size to the fiber mode. The latter degree appears to be fairly robust and does not need to be frequently reoptimized; here we will implement control of a single MEMS mirror as a basic introduction to the EMERGENT workflow.</p>
<p>Our actuator of choice is the bonded MEMS mirror from Mirrorcle, driven by their PicoAmp board. The board is controlled with SPI from a LabJack, which is fully implemented in the emergent/devices scripts labjackT7.py and picoAmp.py. The wiring scheme to connect the two boards can be found here.</p>
<p>The other key ingredient is a photodiode to measure the fiber coupling efficiency, which will be the optimization signal that EMERGENT will try to optimize via automated tip/tilt control. Set up the photodiode on the other side of the fiber from the mirror and connect its output to the AIN0 channel of the LabJack.</p>
<p>The experimental layout is shown in Figure 1. We have included an additional kinematic mirror before the MEMS to allow the setup to be manually aligned (beam centered on the MEMS and on the fiber tip) before automating the problem. Though EMERGENT will eventually support first-light acquisition methods, this example will assume that the optimization begins with a small amount of optical power transmitted through the fiber.</p>
</div>
<div class="section" id="building-the-network">
<h3>Building the network<a class="headerlink" href="#building-the-network" title="Permalink to this headline">¶</a></h3>
<p>The network architecture for the fiber coupling problem is shown in Figure 2. The tip and tilt degrees of freedom comprise two Input nodes, labeled X and Y. The Device node takes these two nodes as inputs and physically actuates the mirror using the driver in <code class="docutils literal"><span class="pre">emergent/devices/picoAmp.py</span></code>. The output of the Device node is connected to an Optimizer node, which measures the fiber-coupled power and sends commands to the Device node to optimize the efficiency.</p>
<p>The first step in building the network is to define a custom control node for our alignment task:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AutoAlign</span><span class="p">(</span><span class="n">Control</span><span class="p">):</span>
      <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">labjack</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
               <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">labjack</span> <span class="o">=</span> <span class="n">LabJack</span><span class="p">()</span>

      <span class="k">def</span> <span class="nf">cost</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">actuate</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
               <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">labjack</span><span class="o">.</span><span class="n">AIn</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we can connect to the LabJack and instantiate the Control node:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">devid</span> <span class="o">=</span> <span class="s1">&#39;160049734&#39;</span>
<span class="n">labjack</span> <span class="o">=</span> <span class="n">LabJack</span><span class="p">(</span><span class="n">devid</span><span class="o">=</span><span class="n">devid</span><span class="p">)</span>
<span class="n">control</span> <span class="o">=</span> <span class="n">AutoAlign</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;control&#39;</span><span class="p">,</span> <span class="n">labjack</span><span class="o">=</span><span class="n">labjack</span><span class="p">)</span>
</pre></div>
</div>
<p>The final step is to define the Device node based on the custom class in <code class="docutils literal"><span class="pre">emergent/devices/picoAmp.py</span></code> and add Inputs:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">mems</span> <span class="o">=</span> <span class="n">PicoAmp</span><span class="p">(</span><span class="s1">&#39;MEMS&#39;</span><span class="p">,</span> <span class="n">labjack</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">control</span><span class="p">)</span>
<span class="n">mems</span><span class="o">.</span><span class="n">add_input</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">mems</span><span class="o">.</span><span class="n">add_input</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the first argument to the <code class="docutils literal"><span class="pre">add_input</span></code> function should match one of the inputs defined in the Device driver, which in this case are <code class="docutils literal"><span class="pre">X</span></code> and <code class="docutils literal"><span class="pre">Y</span></code>. The remaining arguments are the value and min/max values of the inputs, respectively.</p>
</div>
<div class="section" id="manual-operation">
<h3>Manual operation<a class="headerlink" href="#manual-operation" title="Permalink to this headline">¶</a></h3>
<p>With the experiment built and the network constructed, let's now take manual control to familiarize ourselves with the command format. First, let's move the mirror. There are two ways we can do this; first, we could call the actuate() method to move the X and Y to new values, say -1 and 1:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">MEMS</span><span class="o">.</span><span class="n">actuate</span><span class="p">({</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">})</span>
</pre></div>
</div>
<p>Note that we don't have to specify any values we don't want to change: passing in <code class="docutils literal"><span class="pre">{'X':-1}</span></code> will update <code class="docutils literal"><span class="pre">X</span></code> but leave <code class="docutils literal"><span class="pre">Y</span></code> unchanged.</p>
<p>Alternately, we could have changed the state of the input nodes directly:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">MEMS</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">MEMS</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>This will call the actuate() method indirectly, so it is functionally nearly identical to the first approach, but will offer greater flexibility when running EMERGENT in a GUI.</p>
<p>After moving the mirror, you should have seen the coupling efficiency change. The power can be measured by calling <code class="docutils literal"><span class="pre">control.cost()</span></code>, which will read the LabJack's channel AIN0 and multiply by -1 (by convention, all optimization problems are cast as minimization).</p>
<p>We can also save the new state by calling <code class="docutils literal"><span class="pre">control.save()</span></code>, which writes the current settings to a json file in <code class="docutils literal"><span class="pre">emergent/examples/MEMS_align/settings</span></code>. Calling <code class="docutils literal"><span class="pre">control.load()</span></code> will allow the saved state to be recovered.</p>
</div>
<div class="section" id="automated-operation">
<h3>Automated operation<a class="headerlink" href="#automated-operation" title="Permalink to this headline">¶</a></h3>
<p>We are finally ready to unveil the holy grail of EMERGENT - automatic device optimization. By calling <code class="docutils literal"><span class="pre">control.optimizer.optimize()</span></code>, the inputs will be tuned to maximize the fiber-coupled efficiency. Many different algorithms are implemented in EMERGENT and can be passed in through the <code class="docutils literal"><span class="pre">method</span></code> keyword argument; in general, the ideal algorithm will be chosen for a given application. We will first demonstrate the simplest possible algorithm, a two-dimensional grid-search.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">control</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;grid_search&#39;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;steps&#39;</span><span class="p">:</span><span class="mi">20</span><span class="p">,</span> <span class="s1">&#39;plot&#39;</span><span class="p">:</span><span class="bp">True</span><span class="p">})</span>
</pre></div>
</div>
<p>This call to grid_search will create a 20x20 grid in the XY plane, sample each point, and move to the best point. If the parameter 'plot' is True, the cost function evaluated over the grid will be plotted. This allows easy visualization of cost landscapes for lower-dimensional problems, but the aggressive complexity scaling of grid_search in the number of dimensions and steps prohibits its use for higher dimensions.</p>
<p>A more sophisticated algorithm is the Nelder-Mead method:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">control</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;Nelder-Mead&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Rather than scanning the entire space, the Nelder-Mead method attempts to efficiently move a N+1 dimensional simplex through an N dimensional cost landscape towards a minimum.</p>
</div>
</div>
<div class="section" id="subspace-partitioning">
<h2>Subspace partitioning<a class="headerlink" href="#subspace-partitioning" title="Permalink to this headline">¶</a></h2>
<p>A powerful feature of EMERGENT is the automatic identification of coupled variables, allowing high-dimensional optimization problems to be decomposed into separate lower-dimensional problems. For example, the idealized fiber coupling problem can be modeled as minimization in a Gaussian cost landscape, which contains no couplings between the X and Y degrees of freedom; therefore, we can run quick 1D line searches in each variable rather than a 2D simultaneous optimization, significantly reducing the size of the search space.</p>
<p>Rather than the physical fiber coupling example above, we will now switch to a virtual cost function to facilitate demonstration of EMERGENT's subspace identification features. The code for this tutorial can be found in <code class="docutils literal"><span class="pre">emergent/examples/subspace_identification</span></code>. Navigate to this directory and run main.py within an IPython console.</p>
<p>We analyze a simple network consisting of a control node implementing several virtual cost functions and a trivial device node which maps two virtual inputs, X and Y, to user-defined values. Two cost functions are implemented: <code class="docutils literal"><span class="pre">control.cost_uncoupled</span></code> and <code class="docutils literal"><span class="pre">control.cost_coupled</span></code>. The former is simply a multivariate Gaussian with a relative factor of ½ between the widths in the X and Y directions; the latter also rotates the inputs by 30 degrees to create a coupling between X and Y.</p>
<div class="section" id="uncoupled-optimization">
<h3>Uncoupled optimization<a class="headerlink" href="#uncoupled-optimization" title="Permalink to this headline">¶</a></h3>
<p>Let's inspect the uncoupled landscape with the grid_search algorithm:</p>
<p>To analyze couplings between degrees of freedom, run:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">control</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">covariance</span><span class="p">(</span><span class="n">cost</span> <span class="o">=</span> <span class="n">control</span><span class="o">.</span><span class="n">cost_uncoupled</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;grid_search&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This will generate and return a covariance matrix through sampling on a uniform grid; couplings can be identified through nonzero off-diagonal elements. In this case, we see that the off-diagonal elements are zero (within an error threshold due to finite sampling), so we can move away from the minimum then optimize the cost through two separate 1D optimizations:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">control</span><span class="o">.</span><span class="n">actuate</span><span class="p">({</span><span class="s1">&#39;MEMS.X&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;MEMS.Y&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">})</span>
<span class="n">control</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;grid_search&#39;</span><span class="p">,</span> <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">MEMS</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]],</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">control</span><span class="o">.</span><span class="n">cost_uncoupled</span><span class="p">)</span>
<span class="n">control</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;grid_search&#39;</span><span class="p">,</span> <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">MEMS</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]],</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">control</span><span class="o">.</span><span class="n">cost_uncoupled</span><span class="p">)</span>
</pre></div>
</div>
<p>Since the system is perfectly uncoupled, we converge to the local minimum after only 2N iterations for N steps, whereas a coupled system will require N^2 steps to tile the XY plane.</p>
<p>Note that calling <code class="docutils literal"><span class="pre">control.optimize()</span></code> without specifying arguments will eventually automatically partition the system into subspaces as evaluated by the last call to <code class="docutils literal"><span class="pre">control.covariance()</span></code> (feature coming soon).</p>
</div>
<div class="section" id="coupled-optimization">
<h3>Coupled optimization<a class="headerlink" href="#coupled-optimization" title="Permalink to this headline">¶</a></h3>
<p>Now let's inspect the landscape of the coupled cost function:
algorithm:</p>
<p>We once again compute the covariance matrix:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">cov</span> <span class="o">=</span> <span class="n">control</span><span class="o">.</span><span class="n">covariance</span><span class="p">(</span><span class="n">cost</span> <span class="o">=</span> <span class="n">control</span><span class="o">.</span><span class="n">cost_coupled</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;grid_search&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Since we now observe nonzero off-diagonal elements, we know that separate 1D optimizations will not converge to the minimum. Instead, we must optimize in 2D:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">control</span><span class="o">.</span><span class="n">actuate</span><span class="p">({</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">})</span>
<span class="n">control</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;grid_search&#39;</span><span class="p">,</span> <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">MEMS</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">],</span> <span class="n">MEMS</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]],</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">control</span><span class="o">.</span><span class="n">cost_coupled</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="subspace-decoupling">
<h3>Subspace decoupling<a class="headerlink" href="#subspace-decoupling" title="Permalink to this headline">¶</a></h3>
<p>In the previous two sections, we have seen that uncoupled cost functions can be optimized much more efficiently than coupled functions; in d dimensions and N steps, grid_search will require N^d steps for fully-coupled functions and only Nd for uncoupled functions. EMERGENT contains built-in tools to decouple the cost function through principal component analysis (PCA), a process analogous to diagonalizing the covariance matrix. To use this feature, just run</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">control</span><span class="o">.</span><span class="n">diagonalize</span><span class="p">(</span><span class="n">cov</span> <span class="o">=</span> <span class="n">cov</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">diagonalize()</span></code> method produces new virtual Input nodes which are eigenvectors of the covariance matrix. Now the optimization can be run in the decoupled cost landscape with the <code class="docutils literal"><span class="pre">input_type</span></code> flag:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">control</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;grid_search&#39;</span><span class="p">,</span> <span class="n">input_type</span><span class="o">=</span><span class="s1">&#39;virtual&#39;</span><span class="p">,</span> <span class="n">cost</span><span class="o">=</span><span class="n">control</span><span class="o">.</span><span class="n">cost_coupled</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that when using virtual inputs, the <code class="docutils literal"><span class="pre">optimize()</span></code> method automatically targets individual degrees of freedom sequentially.</p>
</div>
</div>
<div class="section" id="sequencing">
<h2>Sequencing<a class="headerlink" href="#sequencing" title="Permalink to this headline">¶</a></h2>
<p>The examples above have shown how to use EMERGENT with steady-state optimization schemes. However, experimental outputs often depend on time-dependent inputs; for example, cold atom experiments are frequently enhanced with a ramp of the laser frequency, magnetic field strength, or some other parameter. Such sequences can be parameterized as a list of tuples containing times <cite>t</cite> and setpoints <cite>s</cite>, such as</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<p>Now we add the sequence to the <code class="docutils literal"><span class="pre">X</span></code> variable and register it with the master clock, which synchronizes sequences across all devices:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">MEMS</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">s</span>
<span class="n">control</span><span class="o">.</span><span class="n">clock</span><span class="o">.</span><span class="n">add_input</span><span class="p">(</span><span class="n">MEMS</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Adding the input to the clock lets EMERGENT know that we want to run <code class="docutils literal"><span class="pre">X</span></code> in sequenced, not steady-state, operation. The last step is to start the clock with <a href="#id1"><span class="problematic" id="id2">``</span></a>control.clock.start(T=0.5)''. Note that the time values in the sequence definition correspond to fractions of the total cycle, so with this cycle of 0.5 s, the MEMS will move to a position of 3 after 250 ms, then back to 0 after each new cycle starts.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Robert Fasano.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1alpha',
            LANGUAGE:'python',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>